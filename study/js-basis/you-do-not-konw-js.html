<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你不知道的 JavaScript（中卷） | Yanxu Gong's Blog</title>
    <meta name="description" content="Personal blog based on Github Action + VitePress">
    <link rel="stylesheet" href="/blog-next/assets/style.88a1b92e.css">
    <link rel="modulepreload" href="/blog-next/assets/chunks/AlgoliaSearchBox.dd75b3aa.js">
    <link rel="modulepreload" href="/blog-next/assets/app.acdedced.js">
    <link rel="modulepreload" href="/blog-next/assets/study_js-basis_you-do-not-konw-js.md.646fef6b.lean.js">
    
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
  <meta name="twitter:title" content="你不知道的 JavaScript（中卷） | Yanxu Gong&#39;s Blog">
  <meta property="og:title" content="你不知道的 JavaScript（中卷） | Yanxu Gong&#39;s Blog">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-95cd145e><div class="sidebar-button" data-v-95cd145e><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/blog-next/" aria-label="Yanxu Gong&#39;s Blog, back to home" data-v-95cd145e data-v-2627e0f1><img class="logo" src="/blog-next/logo.svg" alt="Logo" data-v-2627e0f1> Yanxu Gong&#39;s Blog</a><div class="flex-grow" data-v-95cd145e></div><div class="nav" data-v-95cd145e><nav class="nav-links" data-v-95cd145e data-v-b68e4bf6><!--[--><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item active" href="/blog-next/study/" data-v-43e5dab6>学习 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/photography/" data-v-43e5dab6>摄影 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/emotion/" data-v-43e5dab6>情感 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/about/" data-v-43e5dab6>关于 <!----></a></div></div><!--]--><!----><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item isExternal" href="https://github.com/yanxugong/blog-next" target="_blank" rel="noopener noreferrer" data-v-43e5dab6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-43e5dab6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--[--><div class="algolia-search-box" id="docsearch"></div><!--]--><!--]--></header><aside class="sidebar" data-v-1c2cc348><nav class="nav-links nav" data-v-1c2cc348 data-v-b68e4bf6><!--[--><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item active" href="/blog-next/study/" data-v-43e5dab6>学习 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/photography/" data-v-43e5dab6>摄影 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/emotion/" data-v-43e5dab6>情感 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/about/" data-v-43e5dab6>关于 <!----></a></div></div><!--]--><!----><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item isExternal" href="https://github.com/yanxugong/blog-next" target="_blank" rel="noopener noreferrer" data-v-43e5dab6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-43e5dab6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-1c2cc348><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#前言">前言</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#强制类型转换">强制类型转换</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#值类型转换">值类型转换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#抽象值操作">抽象值操作</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#显示强制类型转换">显示强制类型转换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#隐式强制类型转换">隐式强制类型转换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#宽松相等和严格相等">宽松相等和严格相等</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#语法">语法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#错误">错误</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#回调">回调</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#省点回调">省点回调</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise">Promise</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-信任问题">Promise 信任问题</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#链式流">链式流</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-局限性">Promise 局限性</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#感谢">感谢</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-3d00e640><div class="container" data-v-3d00e640><!--[--><!--]--><div style="position:relative;" class="content" data-v-3d00e640><div><h1 id="你不知道的-javascript（中卷）" tabindex="-1">你不知道的 JavaScript（中卷） <a class="header-anchor" href="#你不知道的-javascript（中卷）" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>本文主要给大家带来一些我读《你不知道的 JavaScript（中卷）》中遇到的一些<strong>有意思</strong>的内容，可以说是<strong>打开新世界的大门</strong>的感觉。希望能在工作之余，给大家带来一点乐趣。</p><blockquote><p>JavaScript 是一门优秀的语言。只学其中一部分内容很容易，但是要全面掌握则很难。开发人员遇到困难时往往将其归咎于语言本身，而不反省他们自己对语言的理解有多匮乏。《你不知道的 JavaScript》旨在解决这个问题，使读者能够发自内心地喜欢上这门语言。</p></blockquote><h2 id="强制类型转换" tabindex="-1">强制类型转换 <a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a></h2><h3 id="值类型转换" tabindex="-1">值类型转换 <a class="header-anchor" href="#值类型转换" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 隐式强制类型转换</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显式强制类型转换</span>
</code></pre></div><h3 id="抽象值操作" tabindex="-1">抽象值操作 <a class="header-anchor" href="#抽象值操作" aria-hidden="true">#</a></h3><blockquote><p><code>document.all</code> 是假值对象。也就是 <code>!!document.all</code> 值为 <code>false</code>。</p></blockquote><h3 id="显示强制类型转换" tabindex="-1">显示强制类型转换 <a class="header-anchor" href="#显示强制类型转换" aria-hidden="true">#</a></h3><h4 id="日期显示转换为数字：" tabindex="-1">日期显示转换为数字： <a class="header-anchor" href="#日期显示转换为数字：" aria-hidden="true">#</a></h4><p>使用 <code>Date.now()</code> 来获得当前的时间戳，使用 <code>new Date(..).getTime()</code> 来获得指定时间的时间戳。</p><h4 id="奇特的-运算符：" tabindex="-1">奇特的 ~ 运算符： <a class="header-anchor" href="#奇特的-运算符：" aria-hidden="true">#</a></h4><p><code>~x</code> 大致等同于 <code>-(x+1)</code>。很奇怪，但相对更容易说明问题： <code>~42; // -(42+1) ==&gt; -43</code></p><p>JavaScript 中字符串的 <code>indexOf(..)</code> 方法也遵循这一惯例，该方法在字符串中搜索指定的子 字符串，如果找到就返回子字符串所在的位置（从 0 开始），否则返回 -1。</p><p><code>~</code> 和 <code>indexOf()</code> 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值：</p><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span>
<span class="token operator">~</span>a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;lo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -4 &lt;-- 真值!</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;lo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// true</span>
  <span class="token comment">// 找到匹配！</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="解析非字符串：" tabindex="-1">解析非字符串： <a class="header-anchor" href="#解析非字符串：" aria-hidden="true">#</a></h4><p>曾经有人发帖吐槽过 <code>parseInt(..)</code> 的一个坑：</p><div class="language-js"><pre><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 18</span>
</code></pre></div><p><code>parseInt(1/0, 19)</code> 实际上是 <code>parseInt(&quot;Infinity&quot;, 19)</code>。第一个字符是 &quot;I&quot;，以 19 为基数 时值为 18。</p><p>此外还有一些看起来奇怪但实际上解释得通的例子：</p><div class="language-js"><pre><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">0.000008</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 (&quot;0&quot; 来自于 &quot;0.000008&quot;)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">0.0000008</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8 (&quot;8&quot; 来自于 &quot;8e-7&quot;)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 250 (&quot;fa&quot; 来自于 &quot;false&quot;)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15 (&quot;f&quot; 来自于 &quot;function..&quot;)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0x10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;103&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><h3 id="隐式强制类型转换" tabindex="-1">隐式强制类型转换 <a class="header-anchor" href="#隐式强制类型转换" aria-hidden="true">#</a></h3><h4 id="字符串和数字之间的隐式强制类型转换" tabindex="-1">字符串和数字之间的隐式强制类型转换 <a class="header-anchor" href="#字符串和数字之间的隐式强制类型转换" aria-hidden="true">#</a></h4><p>例如：</p><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;420&quot;</span>
c <span class="token operator">+</span> d<span class="token punctuation">;</span> <span class="token comment">// 42</span>
</code></pre></div><p>再例如：</p><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;1,23,4&quot;</span>
</code></pre></div><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作（规范 9.1 节），该抽象操作再调用 <code>[[DefaultValue]]</code>（规范 8.12.8 节），以数字作为上下文。</p><p>你或许注意到这与 <code>ToNumber</code> 抽象操作处理对象的方式一样（参见 4.2.2 节）。因为数组的 <code>valueOf()</code> 操作无法得到简单基本类型值，于是它转而调用 <code>toString()</code>。因此上例中的两个数组变成了 &quot;<code>1,2</code>&quot; 和 &quot;<code>3,4</code>&quot; 。+ 将它们拼接后返回 &quot;<code>1,23,4</code>&quot; 。</p><p><strong>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。</strong></p><h4 id="符号的强制类型转换" tabindex="-1">符号的强制类型转换 <a class="header-anchor" href="#符号的强制类型转换" aria-hidden="true">#</a></h4><p>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误，具体的原因不在本书讨论范围之内。</p><p>例如：</p><div class="language-js"><pre><code><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;cool&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">String</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Symbol(cool)&quot;</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;not cool&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s2 <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError</span>
</code></pre></div><p>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 <code>true</code>）。</p><p>由于规则缺乏一致性，我们要对 ES6 中符号的强制类型转换多加小心。</p><p>好在鉴于符号的特殊用途，我们不会经常用到它的强制类型转换。</p><h3 id="宽松相等和严格相等" tabindex="-1">宽松相等和严格相等 <a class="header-anchor" href="#宽松相等和严格相等" aria-hidden="true">#</a></h3><p>常见的误区是“<code>==</code> 检查值是否相等，<code>===</code> 检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。</p><p>正确的解释是：“<code>==</code> 允许在相等比较中进行强制类型转换，而 <code>===</code> 不允许。”</p><p>字符串和数字之间的相等比较：</p><ul><li>如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。</li><li>如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</li></ul><p>其他类型和布尔类型之间的相等比较：</p><ul><li>如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</li><li>如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</li></ul><p><code>null</code> 和 <code>undefined</code> 之间的相等比较：</p><ul><li>如果 x 为 null，y 为 undefined，则结果为 true。</li><li>如果 x 为 undefined，y 为 null，则结果为 true。</li></ul><p>对象和非对象之间的相等比较：</p><ul><li>如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；</li><li>如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</li></ul><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-hidden="true">#</a></h2><h3 id="错误" tabindex="-1">错误 <a class="header-anchor" href="#错误" aria-hidden="true">#</a></h3><p>提前使用变量</p><p>ES6 规范定义了一个新概念，叫作 TDZ（Temporal Dead Zone，暂时性死区）。</p><p>TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p><p>对此，最直观的例子是 ES6 规范中的 <code>let</code> 块作用域：</p><div class="language-js"><pre><code><span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError!</span>
  <span class="token keyword">let</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>a = 2</code> 试图在 <code>let a</code> 初始化 <code>a</code> 之前使用该变量（其作用域在 <code>{ .. }</code> 内），这里就是 <code>a</code> 的 TDZ，会产生错误。</p><p>有意思的是，对未声明变量使用 typeof 不会产生错误（参见第 1 章），但在 TDZ 中却会报错：</p><div class="language-js"><pre><code><span class="token punctuation">{</span>
  <span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// undefined</span>
  <span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// ReferenceError! (TDZ)</span>
  <span class="token keyword">let</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="回调" tabindex="-1">回调 <a class="header-anchor" href="#回调" aria-hidden="true">#</a></h2><h3 id="省点回调" tabindex="-1">省点回调 <a class="header-anchor" href="#省点回调" aria-hidden="true">#</a></h3><p>构造一个超时验证工具：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">timeoutify</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> intv <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    intv <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Timeout!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 还没有超时？</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>intv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>intv<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以下是使用方式：</p><div class="language-js"><pre><code><span class="token comment">// 使用 ‘error-first 风格’ 回调设计</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;http://some.url.1&quot;</span><span class="token punctuation">,</span> <span class="token function">timeoutify</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你不确定关注的 API 会不会永远异步执行怎么办呢？可以创建一个类似于这个“验证概念”版本的 <code>asyncify(..)</code> 工具：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">asyncify</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> orig_fn <span class="token operator">=</span> fn<span class="token punctuation">,</span>
    intv <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      intv <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 触发太快，在定时器intv触发指示异步转换发生之前？</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>intv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn <span class="token operator">=</span> orig_fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
        orig_fn<span class="token punctuation">,</span>
        <span class="token comment">// 把封装器的this添加到bind(..)调用的参数中，</span>
        <span class="token comment">// 以及克里化（currying）所有传入参数</span>
        <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 已经是异步</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用原来的函数</span>
      <span class="token function">orig_fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以像这样使用 <code>asyncify(..)</code>：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;..pre-cached-url..&quot;</span><span class="token punctuation">,</span> <span class="token function">asyncify</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre></div><p>不管这个 Ajax 请求已经在缓存中并试图对回调立即调用，还是要从网络上取得，进而在将来异步完成，这段代码总是会输出 1，而不是 0——result(..) 只能异步调用，这意味着 a++ 有机会在 result(..) 之前运行。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h2><h3 id="promise-信任问题" tabindex="-1">Promise 信任问题 <a class="header-anchor" href="#promise-信任问题" aria-hidden="true">#</a></h3><h4 id="回调未调用" tabindex="-1">回调未调用 <a class="header-anchor" href="#回调未调用" aria-hidden="true">#</a></h4><p>提供一个超时处理的解决方案：</p><div class="language-js"><pre><code><span class="token comment">// 用于超时一个Promise的工具</span>
<span class="token keyword">function</span> <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;Timeout!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置foo()超时</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// foo(..)及时完成！</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 或者foo()被拒绝，或者只是没能按时完成</span>
    <span class="token comment">// 查看err来了解是哪种情况</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="链式流" tabindex="-1">链式流 <a class="header-anchor" href="#链式流" aria-hidden="true">#</a></h3><p>为了进一步阐释链接，让我们把延迟 Promise 创建（没有决议消息）过程一般化到一个工具中，以便在多个步骤中复用：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 步骤1</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">STEP2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;step 2 (after 100ms)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">STEP3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;step 3 (after another 200ms)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">STEP4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;step 4 (next Job)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">STEP5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;step 5 (after another 50ms)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>调用 <code>delay(200)</code> 创建了一个将在 200ms 后完成的 promise，然后我们从第一个 <code>then(..)</code> 完成回调中返回这个 promise，这会导致第二个 <code>then(..)</code> 的 promise 等待这个 200ms 的 promise。</p><h3 id="promise-局限性" tabindex="-1">Promise 局限性 <a class="header-anchor" href="#promise-局限性" aria-hidden="true">#</a></h3><h4 id="顺序错误处理" tabindex="-1">顺序错误处理 <a class="header-anchor" href="#顺序错误处理" aria-hidden="true">#</a></h4><p>Promise 的设计局限性（链式调用）造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被无意中默默忽略掉。</p><p>关于 Promise 错误，还有其他需要考虑的地方。由于一个 Promise 链仅仅是连接到一起的成员 Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误。</p><p>如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到在某个步骤注册拒绝处理函数。在这个特定的例子中，只要有一个指向链中最后一个 promise 的引用就足够了（下面代码中的 p），因为你可以在那里注册拒绝处理函数，而且这个处理函数能够得到所有传播过来的错误的通知：</p><div class="language-js"><pre><code><span class="token comment">// foo(..), STEP2(..)以及STEP3(..)都是支持promise的工具</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token constant">STEP2</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token constant">STEP3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然这里可能令人迷惑，但是这里的 <code>p</code> 并不指向链中的第一个 promise（调用 <code>foo(42)</code> 产生的那一个），而是指向最后一个 promise，即来自调用 <code>then(STEP3)</code> 的那一个。</p><p>还有，这个 Promise 链中的任何一个步骤都没有显式地处理自身错误。这意味着你可以在 <code>p</code> 上注册一个拒绝错误处理函数，对于链中任何位置出现的任何错误，这个处理函数都会得到通知：</p><div class="language-js"><pre><code>p<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>handleErrors<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是，如果链中的任何一个步骤事实上进行了自身的错误处理（可能以隐藏或抽象的不可见的方式），那你的 <code>handleErrors(..)</code> 就不会得到通知。这可能是你想要的——毕竟这是一个“已处理的拒绝”——但也可能并不是。不能清晰得到（对具体某一个“已经处理”的拒绝的）错误通知也是一个缺陷，它限制了某些用例的功能。</p><p>基本上，这等同于 try..catch 存在的局限：try..catch 可能捕获一个异常并简单地吞掉它。所以这并不是 Promise 独有的局限性，但可能是我们希望绕过的陷阱。</p><p>遗憾的是，很多时候并没有为 Promise 链序列的中间步骤保留的引用。因此，没有这样的引用，你就无法关联错误处理函数来可靠地检查错误。</p><h4 id="单一值" tabindex="-1">单一值 <a class="header-anchor" href="#单一值" aria-hidden="true">#</a></h4><p>根据定义，Promise 只能有一个完成值或一个拒绝理由。在简单的例子中，这不是什么问题，但是在更复杂的场景中，你可能就会发现这是一种局限了。</p><p>一般的建议是构造一个值封装（比如一个对象或数组）来保持这样的多个信息。这个解决方案可以起作用，但要在 Promise 链中的每一步都进行封装和解封，就十分丑陋和笨重了。</p><ol><li>分裂值</li></ol><p>有时候，你可以把这一点，当作提示你应该把问题分解为两个或更多 Promise 的信号。</p><p>设想你有一个工具 <code>foo(..)</code>，它可以异步产生两个值（x 和 y）：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">bar<span class="token punctuation">,</span> baz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> bar <span class="token operator">*</span> baz<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">getY</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 把两个值封装到容器中</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>首先，我们重新组织一下 <code>foo(..)</code> 返回的内容，这样就不再需要把 <code>x</code> 和 <code>y</code> 封装到一个数组值中以通过 promise 传输。取而代之的是，我们可以把每个值封装到它自己的 promise：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">bar<span class="token punctuation">,</span> baz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> bar <span class="token operator">*</span> baz<span class="token punctuation">;</span>

  <span class="token comment">// 返回两个 promise</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getY</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一个 promise 数组真的要优于传递给单个 promise 的一个值数组吗？从语法的角度来说，这算不上是一个改进。</p><p>但是，这种方法更符合 Promise 的设计理念。如果以后需要重构代码把对 <code>x</code> 和 <code>y</code> 的计算分开，这种方法就简单得多。由调用代码来决定如何安排这两个 promise，而不是把这种细节放在 <code>foo(..)</code> 内部抽象，这样更整洁也更灵活。这里使用了 <code>Promise.all([ .. ])</code>，当然，这并不是唯一的选择。</p><ol start="2"><li>传递参数</li></ol><p><code>var x = ..</code> 和 <code>var y = ..</code> 赋值操作仍然是麻烦的开销。我们可以在辅助工具中采用某种函数技巧：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 200 599</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样会好一点！当然，你可以把这个函数戏法在线化，以避免额外的辅助工具：</p><div class="language-js"><pre><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  Function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 200 599</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这些技巧可能很灵巧，但 ES6 给出了一个更好的答案：解构。数组解构赋值形式看起来是这样的：</p><div class="language-js"><pre><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> msgs<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不过最好的是，ES6 提供了数组参数解构形式：</p><div class="language-js"><pre><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在，我们符合了“每个 Promise 一个值”的理念，并且又将重复样板代码量保持在了最小！</p><h4 id="单决议" tabindex="-1">单决议 <a class="header-anchor" href="#单决议" aria-hidden="true">#</a></h4><p>Promise 最本质的一个特征是：Promise 只能被决议一次（完成或拒绝）。在许多异步情况中，你只会获取一个值一次，所以这可以工作良好。</p><p>但是，还有很多异步的情况适合另一种模式——一种类似于事件或数据流的模式。在表面上，目前还不清楚 Promise 能不能很好用于这样的用例，如果不是完全不可用的话。如果不在 Promise 之上构建显著的抽象，Promise 肯定完全无法支持多值决议处理。</p><p>设想这样一个场景：你可能要启动一系列异步步骤以响应某种可能多次发生的激励（就像是事件），比如按钮点击。</p><p>这样可能不会按照你的期望工作：</p><div class="language-js"><pre><code><span class="token comment">// click(..) 把&quot;click&quot;事件绑定到一个 DOM 元素</span>
<span class="token comment">// request(..) 是前面定义的支持 Promise 的 Ajax</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">click</span><span class="token punctuation">(</span><span class="token string">&quot;#mybtn&quot;</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> btnID <span class="token operator">=</span> evt<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">&quot;http://some.url.1/?id=&quot;</span> <span class="token operator">+</span> btnID<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>只有在你的应用只需要响应按钮点击一次的情况下，这种方式才能工作。如果这个按钮被点击了第二次的话，promise p 已经决议，因此第二个 <code>resolve(..)</code> 调用就会被忽略。</p><p>因此，你可能需要转化这个范例，为每个事件的发生创建一整个新的 Promise 链：</p><div class="language-js"><pre><code><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">&quot;#mybtn&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> btnID <span class="token operator">=</span> evt<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
  <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">&quot;http://some.url.1/?id=&quot;</span> <span class="token operator">+</span> btnID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种方法可以工作，因为针对这个按钮上的每个 &quot;click&quot; 事件都会启动一整个新的 Promise 序列。</p><p>由于需要在事件处理函数中定义整个 Promise 链，这很丑陋。除此之外，这个设计在某种程度上破坏了关注点与功能分离（SoC）的思想。你很可能想要把事件处理函数的定义和对事件的响应（那个 Promise 链）的定义放在代码中的不同位置。如果没有辅助机制的话，在这种模式下很难这样实现。</p><h2 id="感谢" tabindex="-1">感谢 <a class="header-anchor" href="#感谢" aria-hidden="true">#</a></h2><p>如果本文对你有帮助，就点个 <a href="https://github.com/yanxugong/blog" target="_blank" rel="noopener noreferrer">Star</a> 支持下吧！感谢阅读。</p></div></div><footer class="page-footer" data-v-3d00e640 data-v-0d8328fe><div class="edit" data-v-0d8328fe><div class="edit-link" data-v-0d8328fe data-v-f484245e><a class="link" href="https://github.com/yanxugong/blog-next/edit/main/study/js-basis/you-do-not-konw-js.md" target="_blank" rel="noopener noreferrer" data-v-f484245e>为此页提供修改建议 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-f484245e><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-0d8328fe><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"about_index.md\":\"c8fb677e\",\"emotion_index.md\":\"9df12840\",\"index.md\":\"122593cd\",\"photography_index.md\":\"8ab54a43\",\"study_algorithm_linked-list.md\":\"56de5a22\",\"study_engineering_vite.md\":\"a5e68948\",\"study_engineering_webpack-hmr.md\":\"fd9d7b24\",\"study_engineering_webpack-loader.md\":\"c44e1d7e\",\"study_engineering_webpack-main.md\":\"c92b7e90\",\"study_engineering_webpack-plugin.md\":\"b64db039\",\"study_frame_deep-react-one.md\":\"9567db07\",\"study_frame_deep-react-two.md\":\"647e3106\",\"study_index.md\":\"24d0e116\",\"study_js-basis_implementation-mechanism.md\":\"5724d96f\",\"study_js-basis_prototype-and-prototype-chain.md\":\"dffe13ab\",\"study_js-basis_scope-and-closure.md\":\"128bae09\",\"study_js-basis_syntax-and-api.md\":\"53be698c\",\"study_js-basis_variables-and-types.md\":\"9fcfaf7a\",\"study_js-basis_you-do-not-konw-js-down.md\":\"96afbde7\",\"study_js-basis_you-do-not-konw-js.md\":\"646fef6b\",\"study_network_from-url-to-page-render.md\":\"ffd09749\",\"study_performance-optimization_first-screen.md\":\"0aa2c624\",\"study_server_go-getting-started.md\":\"ce44aeeb\",\"study_vue3_responsive-system.md\":\"d48489bb\"}")</script>
    <script type="module" async src="/blog-next/assets/app.acdedced.js"></script>
    
  </body>
</html>
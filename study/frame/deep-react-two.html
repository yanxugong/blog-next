<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入 react 技术栈（二） | Yanxu Gong's Blog</title>
    <meta name="description" content="Personal blog based on Github Action + VitePress">
    <link rel="stylesheet" href="/blog-next/assets/style.88a1b92e.css">
    <link rel="modulepreload" href="/blog-next/assets/chunks/AlgoliaSearchBox.dd75b3aa.js">
    <link rel="modulepreload" href="/blog-next/assets/app.acdedced.js">
    <link rel="modulepreload" href="/blog-next/assets/study_frame_deep-react-two.md.647e3106.lean.js">
    
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
  <meta name="twitter:title" content="深入 react 技术栈（二） | Yanxu Gong&#39;s Blog">
  <meta property="og:title" content="深入 react 技术栈（二） | Yanxu Gong&#39;s Blog">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-95cd145e><div class="sidebar-button" data-v-95cd145e><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/blog-next/" aria-label="Yanxu Gong&#39;s Blog, back to home" data-v-95cd145e data-v-2627e0f1><img class="logo" src="/blog-next/logo.svg" alt="Logo" data-v-2627e0f1> Yanxu Gong&#39;s Blog</a><div class="flex-grow" data-v-95cd145e></div><div class="nav" data-v-95cd145e><nav class="nav-links" data-v-95cd145e data-v-b68e4bf6><!--[--><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item active" href="/blog-next/study/" data-v-43e5dab6>学习 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/photography/" data-v-43e5dab6>摄影 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/emotion/" data-v-43e5dab6>情感 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/about/" data-v-43e5dab6>关于 <!----></a></div></div><!--]--><!----><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item isExternal" href="https://github.com/yanxugong/blog-next" target="_blank" rel="noopener noreferrer" data-v-43e5dab6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-43e5dab6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--[--><div class="algolia-search-box" id="docsearch"></div><!--]--><!--]--></header><aside class="sidebar" data-v-1c2cc348><nav class="nav-links nav" data-v-1c2cc348 data-v-b68e4bf6><!--[--><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item active" href="/blog-next/study/" data-v-43e5dab6>学习 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/photography/" data-v-43e5dab6>摄影 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/emotion/" data-v-43e5dab6>情感 <!----></a></div></div><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item" href="/blog-next/about/" data-v-43e5dab6>关于 <!----></a></div></div><!--]--><!----><div class="item" data-v-b68e4bf6><div class="nav-link" data-v-b68e4bf6 data-v-43e5dab6><a class="item isExternal" href="https://github.com/yanxugong/blog-next" target="_blank" rel="noopener noreferrer" data-v-43e5dab6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-43e5dab6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-1c2cc348><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#前言">前言</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#usestate-的原理">useState 的原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#usestate-的实现">useState 的实现</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#初步实现">初步实现</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#加强版实现">加强版实现</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#探索-react-内部">探索 react 内部</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#定义-hook">定义 Hook</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#初始化-state">初始化 state</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#更新-state">更新 state</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#调用阶段-dispatchaction">调用阶段 dispatchAction</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#总结">总结</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#参考文章">参考文章</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#感谢">感谢</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-3d00e640><div class="container" data-v-3d00e640><!--[--><!--]--><div style="position:relative;" class="content" data-v-3d00e640><div><h1 id="深入-react-技术栈（二）" tabindex="-1">深入 react 技术栈（二） <a class="header-anchor" href="#深入-react-技术栈（二）" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>近期在工作过程中遇到了 react 状态管理的问题，后面查阅了一些文章，发现关于 <strong>useState</strong> 的原理解析比较少。所以这篇文章从<strong>讲解原理</strong>出发，到<strong>简单实现</strong>，并列出<strong>代码示例</strong>。希望能给大家带来一些帮助，今后遇到状态管理的问题都能迎刃而解。</p><blockquote><p>温馨提示：使用 react 时，了解源码（react 源码比 vue 源码复杂）内容并不是必要条件。本文偏探索 react 内部如何运作比较多，所以这里<strong>适用对象</strong>包括：对 <strong>react 内部运行机制</strong>感兴趣的同学和<strong>熟练使用 Hook</strong> 的同学。这里本人非常提倡大家能在日常工作使用更多的 Hook 来<strong>减少代码实现</strong>或者<strong>逻辑解耦</strong>。</p></blockquote><p>class 组件经常会使人们难以理解，并且大大增加我们的代码量。使用 Hooks 不仅解决了这两个问题，它还有其他优点，其中包括：</p><ul><li>易于构建和重用部分状态逻辑</li><li>更容易将复杂的组件拆分为多个小模块</li><li>避免了生命周期混乱的情况</li><li>更容易添加状态类型</li><li>更有利于代码进行单元测试</li></ul><p>因此，这很容易让我们产生疑问，为什么 Hooks 这么强大？</p><h2 id="usestate-的原理" tabindex="-1">useState 的原理 <a class="header-anchor" href="#usestate-的原理" aria-hidden="true">#</a></h2><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>看一个官方示例：</p><div class="language-js"><pre><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 声明一个 state 变量</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>温馨提示：函数组件没有实例，也没有状态。它的渲染只是一个<strong>执行函数获取返回值</strong>然后<strong>渲染</strong>的过程。</p></blockquote><p>组件中 useState 会返回<strong>当前状态</strong>和<strong>更新状态的方法</strong>。初始状态只会在函数第一次执行的时候赋值。每当状态改变之后，视图会重新渲染。其中，假如 Hooks 中存在多个 useState 的时候，我们可以尝试用数组保存这些状态。</p><p>下面，我们试着自己动手实现一个 useState 。</p><h2 id="usestate-的实现" tabindex="-1">useState 的实现 <a class="header-anchor" href="#usestate-的实现" aria-hidden="true">#</a></h2><h3 id="初步实现" tabindex="-1">初步实现 <a class="header-anchor" href="#初步实现" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token comment">// 把状态放在最外面，方便记录 state 的变更</span>
<span class="token keyword">let</span> state<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">useState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">initialValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> state <span class="token operator">||</span> initialValue<span class="token punctuation">;</span>
  <span class="token comment">// 更新 state 的值</span>
  <span class="token keyword">const</span> <span class="token function-variable function">updateState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> updateState<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// render 方法</span>
<span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  ReactDom<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们实现了对<strong>一个</strong> state 的存储和记忆。实际在日常开发中往往要管理<strong>多个</strong> state 。这里我们想到可以用一个数组，去储存<strong>所有的 state</strong> 。</p><h3 id="加强版实现" tabindex="-1">加强版实现 <a class="header-anchor" href="#加强版实现" aria-hidden="true">#</a></h3><p>现在我们需要优化一下 useState ，解决不能同时管理多个 state 的问题（这里没有考虑组件与组件之间 state 变量命名相同的情况）。</p><div class="language-js"><pre><code><span class="token comment">// 存放所有状态值</span>
<span class="token keyword">let</span> stateArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 记录索引</span>
<span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">useState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">initialValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 记录当前操作的索引</span>
  <span class="token keyword">const</span> currentIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>
  stateArr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> stateArr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">||</span> initialValue<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">updateState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    stateArr<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 避免重复操作当前值</span>
  index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>stateArr<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> updateState<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 每一次 render 都需要重置索引</span>
  index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  ReactDom<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>总结：</p><ol><li>打开页面初次渲染，useState 执行会依次将对应的 updateState 方法绑定到对应索引位置，然后将初始值存入 stateArr 中。</li><li>用户操作，触发 updateState 更新多个索引下的 state 。</li><li>重新渲染，依次执行 useState ，只不过当前的 stateArr 中已经存了最后一次 state 更新之后的值，这里传入 useState 方法的值不在是最开始的初始值，而是最后一次更新后的 state 值。</li></ol><p>我们的简单实现就到这里。其实这里的 useState 和真实的 react 中的 useState 还存在很大的区别。</p><blockquote><p>温馨提示：刚才方法里的 state 对应着 react 中的 <strong>memoizedState</strong> ，真正的 react 存储所有状态的也不是数组结构，而是<strong>链表</strong>。至于<a href="https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/" target="_blank" rel="noopener noreferrer">为什么要用链表</a>结构，大家感兴趣的可以研究一下 <a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=react%20fiber" target="_blank" rel="noopener noreferrer"><strong>react fiber</strong></a> 的实现。react fiber 是 react 核心算法（<strong>调度机制</strong>）的重新实现。一种致力于提升对动画、布局和手势等领域适用性的架构。</p></blockquote><blockquote><p>注意：hook 与 FunctionComponent fiber 都存在 <strong>memoizedState</strong> 属性，不要混淆他们的概念。fiber.memoizedState：FunctionComponent 对应 fiber 保存的 Hooks 链表。hook.memoizedState：Hooks 链表中保存的单一 hook 对应的数据。</p></blockquote><p>那么，react 中是怎样实现 useState 的呢？</p><h2 id="探索-react-内部" tabindex="-1">探索 react 内部 <a class="header-anchor" href="#探索-react-内部" aria-hidden="true">#</a></h2><h3 id="定义-hook" tabindex="-1">定义 Hook <a class="header-anchor" href="#定义-hook" aria-hidden="true">#</a></h3><p>这里看到 <a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L138" target="_blank" rel="noopener noreferrer">ReactFiberHooks.new.js</a> 文件里面，Hook 初始化的几个属性。</p><blockquote><p>为了避免 react 源码可能因 <a href="http://github.com" target="_blank" rel="noopener noreferrer">github.com</a> 网络原因加载缓慢问题，这里源码链接采用 Gitee 中链接代替。</p></blockquote><div class="language-js"><pre><code><span class="token keyword">export</span> type Hook <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">|</span>
  <span class="token comment">// 指向当前渲染节点 Fiber，上一次完整更新之后的最终状态值</span>
  <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 初始化 state，以及每次 dispatch 之后新的 state</span>
  <span class="token literal-property property">baseState</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 当前需要更新的 Update ，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯</span>
  <span class="token literal-property property">baseQueue</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 缓存的更新队列，存储多次更新行为</span>
  <span class="token literal-property property">queue</span><span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向下一个 hook，通过 next 串联每一个 hook</span>
  <span class="token literal-property property">next</span><span class="token operator">:</span> Hook <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token operator">|</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>Update 是一个带着标识符的对象，它是用来标识 react 当前需要更新的内容。有多少个 Update，就表示 react 接下来需要更新多少内容。比如：render 函数调用，或者改变 state 值方法调用的时候，都会创建 Update 更新对象。Update 对象彼此通过 next 相互连接，形成一个单向链表的数据结构。而 UpdateQueue 其实就是用于保存记录 Update 的一个队列。</p><h3 id="初始化-state" tabindex="-1">初始化 state <a class="header-anchor" href="#初始化-state" aria-hidden="true">#</a></h3><h4 id="_1-dispatch" tabindex="-1">1. Dispatch <a class="header-anchor" href="#_1-dispatch" aria-hidden="true">#</a></h4><p><a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1817" target="_blank" rel="noopener noreferrer">HooksDispatcherOnMount</a> 是首次加载时会执行的 Dispatch。</p><blockquote><p>温馨提示：Dispatch 可以理解为改变内部 state 的方法之一。</p></blockquote><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token literal-property property">HooksDispatcherOnMount</span><span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  readContext<span class="token punctuation">,</span>

  <span class="token comment">// 省略其他的 hook</span>
  <span class="token operator">...</span>
  <span class="token literal-property property">useState</span><span class="token operator">:</span> mountState<span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>根据上面的代码，首次加载时，useState 会调用 <a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1126" target="_blank" rel="noopener noreferrer">mountState</a>。</p><h4 id="_2-mountstate" tabindex="-1">2. MountState <a class="header-anchor" href="#_2-mountstate" aria-hidden="true">#</a></h4><div class="language-js"><pre><code><span class="token keyword">function</span> mountState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token literal-property property">initialState</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建并返回当前的hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">...</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">.</span>baseState <span class="token operator">=</span> initialState<span class="token punctuation">;</span>
  <span class="token comment">// 创建 queue</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">pending</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">dispatch</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">lastRenderedReducer</span><span class="token operator">:</span> basicStateReducer<span class="token punctuation">,</span>
    <span class="token literal-property property">lastRenderedState</span><span class="token operator">:</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token literal-property property">dispatch</span><span class="token operator">:</span> Dispatch<span class="token operator">&lt;</span>
    BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    currentlyRenderingFiber<span class="token punctuation">,</span>
    queue<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>回忆下，这里的 mountState 方法和我们刚才实现的<strong>加强版 useState</strong> 对比一下，是不是有内味儿了。mountWorkInProgressHook 方法会创建并返回对应的 hook。需要注意一下的是 queue 里 lastRenderedReducer 的值是 <a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L637" target="_blank" rel="noopener noreferrer">basicStateReducer</a>。也就是说，上一次 render 使用的 reducer 是 basicStateReducer。</p><h4 id="_3-basicstatereducer" tabindex="-1">3. BasicStateReducer <a class="header-anchor" href="#_3-basicstatereducer" aria-hidden="true">#</a></h4><div class="language-js"><pre><code><span class="token keyword">function</span> basicStateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token literal-property property">action</span><span class="token operator">:</span> BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">?</span> <span class="token function">action</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">:</span> action<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>温馨提示：basicStateReducer 会接受两个参数 state 和 action。然后会返回 action(state) 或者 action。个人理解是我们通过传入具体的值修改状态时（例如：setCount(520)），<code>typeof action === &#39;function&#39;</code>不成立，直接返回 action。</p></blockquote><p>我们传入的 action 是一个具体的值：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e577166468194935aa3d475dc6401198~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>当传入 Setter 的是一个 Reducer 函数的时候：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb6080621c447b09d414313b6b9370a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="更新-state" tabindex="-1">更新 state <a class="header-anchor" href="#更新-state" aria-hidden="true">#</a></h3><p><a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1838" target="_blank" rel="noopener noreferrer">HooksDispatcherOnUpdate</a> 是更新时会执行的 Dispatch。这里的 useState 会执行 updateState。</p><h4 id="_1-updatestate" tabindex="-1">1. UpdateState <a class="header-anchor" href="#_1-updatestate" aria-hidden="true">#</a></h4><div class="language-js"><pre><code><span class="token keyword">function</span> updateState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token literal-property property">initialState</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">updateReducer</span><span class="token punctuation">(</span>basicStateReducer<span class="token punctuation">,</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里 updateState 最终会返回 <a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L664" target="_blank" rel="noopener noreferrer">updateReducer</a>。并且传入 basicStateReducer 作为第一个参数。</p><h4 id="_2-updatereducer" tabindex="-1">2. UpdateReducer <a class="header-anchor" href="#_2-updatereducer" aria-hidden="true">#</a></h4><div class="language-js"><pre><code><span class="token keyword">function</span> updateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">reducer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
  <span class="token literal-property property">initialArg</span><span class="token operator">:</span> <span class="token constant">I</span><span class="token punctuation">,</span>
  init<span class="token operator">?</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">I</span></span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>
  <span class="token operator">...</span>

  queue<span class="token punctuation">.</span>lastRenderedReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span>

  <span class="token operator">...</span>
  <span class="token keyword">const</span> <span class="token literal-property property">dispatch</span><span class="token operator">:</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还记得 mountState 方法的 hook 是 mountWorkInProgressHook，而现在 updateReducer 使用的是 updateWorkInProgressHook。可能原因是：</p><ul><li>mountState 只在初始化时调用一次。</li><li>updateReducer 可能在事件回调、副作用里触发更新和 render 阶段触发更新各种情况重复调用，需要条件判断，区别对待。</li></ul><p>整体流程：先找到对应的 hook，然后根据 update 计算出该 hook 的 state 值，最后返回。</p><h3 id="调用阶段-dispatchaction" tabindex="-1">调用阶段 dispatchAction <a class="header-anchor" href="#调用阶段-dispatchaction" aria-hidden="true">#</a></h3><p>最后一个比较大的模块，说一说 <a href="https://gitee.com/yanxu-gong/react-v16.14.0/blob/v16.14.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1686" target="_blank" rel="noopener noreferrer">dispatchAction</a> 的实现。刚才在 mountState 也看到了 dispatchAction 方法，也就是在 useState 调用的时候会执行它。</p><div class="language-js"><pre><code><span class="token keyword">function</span> dispatchAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token literal-property property">fiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">queue</span><span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">action</span><span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token comment">// 创建 update</span>
  <span class="token keyword">const</span> <span class="token literal-property property">update</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    lane<span class="token punctuation">,</span>
    action<span class="token punctuation">,</span>
    <span class="token literal-property property">eagerReducer</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">eagerState</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 将 update 追加到队列的末尾</span>
  <span class="token keyword">const</span> pending <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This is the first update. Create a circular list.</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>

  <span class="token keyword">const</span> alternate <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    fiber <span class="token operator">===</span> currentlyRenderingFiber <span class="token operator">||</span>
    <span class="token punctuation">(</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> alternate <span class="token operator">===</span> currentlyRenderingFiber<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// render 阶段触发的更新</span>
    didScheduleRenderPhaseUpdateDuringThisPass <span class="token operator">=</span> didScheduleRenderPhaseUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      fiber<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> alternate<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// fiber 的更新队列为空时的处理</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRenderedReducer <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
    <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整体流程：先创建 update，然后将 update 追加到队列的末尾，最后开启任务调度。</p><p>currentlyRenderingFiber 指当前的 render 阶段，触发 update 时，通过 bind 方法保证 fiber 和 currentlyRenderingFiber 全等，这代表本次 update 发生于 FunctionComponent 对应 fiber 的 render 阶段。</p><p>fiber.lanes 保存 fiber 上存在的任务调度中 update 的优先级。</p><p><code>fiber.lanes === NoLanes</code> 说明现在 fiber 上没有 update。</p><p>hook 上可能存在多个不同优先级的 update，最终 state 的值由多个 update 共同决定。当 fiber 上不存在 update 时，此时创建的 update 为该 hook 上第一个 update，初始化 state 时也只依赖该 update，所以这里可以通过条件判断避免很多不必要的计算。也就是如果计算出的 state 与该 hook 之前保存的 state 一致，那么完全不需要开启一次调度。即使计算出的 state 与该 hook 之前保存的 state 不一致，在初始化和更新 state 值时也可以直接使用 dispatchAction 已经计算出的 state。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>一句话：state 初始化时创建 hook。触发 dispatch 时按顺序插入 update。updateState 的时候再按顺序触发 reducer。</p><p>大家现在有没有对 useState 有了新的认识了呢？</p><p>最后，文章中没有讲到（但值得拓展）的地方：</p><ul><li>react 新的调度算法（fiber）是如何实现的？</li><li>为什么要用链表结构？</li><li>useEffect 是怎么玩的？</li></ul><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-hidden="true">#</a></h2><ul><li><a href="https://indepth.dev/under-the-hood-of-react-hooks" target="_blank" rel="noopener noreferrer">Under-the-hood of React Hooks</a></li><li><a href="https://react.iamkasong.com/hooks/usestate.html#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88" target="_blank" rel="noopener noreferrer">React 技术揭秘</a></li><li><a href="https://juejin.im/post/6844903990958784526" target="_blank" rel="noopener noreferrer">React Hooks 源码解析</a></li></ul><h2 id="感谢" tabindex="-1">感谢 <a class="header-anchor" href="#感谢" aria-hidden="true">#</a></h2><ul><li>文中如有错误，欢迎在评论区批评指正。</li><li>图片来源网络，版权如有侵犯请联系本人删除。</li><li>如果本文对你有帮助，就点个 <a href="https://github.com/yanxugong/blog" target="_blank" rel="noopener noreferrer">Star</a> 支持下吧！感谢阅读。</li></ul></div></div><footer class="page-footer" data-v-3d00e640 data-v-0d8328fe><div class="edit" data-v-0d8328fe><div class="edit-link" data-v-0d8328fe data-v-f484245e><a class="link" href="https://github.com/yanxugong/blog-next/edit/main/study/frame/deep-react-two.md" target="_blank" rel="noopener noreferrer" data-v-f484245e>为此页提供修改建议 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-f484245e><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-0d8328fe><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"about_index.md\":\"c8fb677e\",\"emotion_index.md\":\"9df12840\",\"index.md\":\"122593cd\",\"photography_index.md\":\"8ab54a43\",\"study_algorithm_linked-list.md\":\"56de5a22\",\"study_engineering_vite.md\":\"a5e68948\",\"study_engineering_webpack-hmr.md\":\"fd9d7b24\",\"study_engineering_webpack-loader.md\":\"c44e1d7e\",\"study_engineering_webpack-main.md\":\"c92b7e90\",\"study_engineering_webpack-plugin.md\":\"b64db039\",\"study_frame_deep-react-one.md\":\"9567db07\",\"study_frame_deep-react-two.md\":\"647e3106\",\"study_index.md\":\"24d0e116\",\"study_js-basis_implementation-mechanism.md\":\"5724d96f\",\"study_js-basis_prototype-and-prototype-chain.md\":\"dffe13ab\",\"study_js-basis_scope-and-closure.md\":\"128bae09\",\"study_js-basis_syntax-and-api.md\":\"53be698c\",\"study_js-basis_variables-and-types.md\":\"9fcfaf7a\",\"study_js-basis_you-do-not-konw-js-down.md\":\"96afbde7\",\"study_js-basis_you-do-not-konw-js.md\":\"646fef6b\",\"study_network_from-url-to-page-render.md\":\"ffd09749\",\"study_performance-optimization_first-screen.md\":\"0aa2c624\",\"study_server_go-getting-started.md\":\"ce44aeeb\",\"study_vue3_responsive-system.md\":\"3b4b540d\"}")</script>
    <script type="module" async src="/blog-next/assets/app.acdedced.js"></script>
    
  </body>
</html>